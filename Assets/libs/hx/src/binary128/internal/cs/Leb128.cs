// Generated by Haxe 4.0.2+606b176a3
using haxe.root;

#pragma warning disable 109, 114, 219, 429, 168, 162
namespace binary128.@internal.cs {
	public class Leb128 : global::haxe.lang.HxObject {
		
		public Leb128(global::haxe.lang.EmptyObject empty) {
		}
		
		
		public Leb128() {
			#line 29 "C:\\HaxeToolkit\\haxe\\lib\\binary128\\0,0,1\\src\\binary128\\internal\\cs\\Leb128.hx"
			global::binary128.@internal.cs.Leb128.__hx_ctor_binary128_internal_cs_Leb128(this);
		}
		#line default
		
		protected static void __hx_ctor_binary128_internal_cs_Leb128(global::binary128.@internal.cs.Leb128 __hx_this) {
		}
		
		
		public static void writeSigned64LEB128(global::haxe.io.BytesOutput buf, long @value) {
			unchecked {
				#line 31 "C:\\HaxeToolkit\\haxe\\lib\\binary128\\0,0,1\\src\\binary128\\internal\\cs\\Leb128.hx"
				bool more = false;
				#line 33 "C:\\HaxeToolkit\\haxe\\lib\\binary128\\0,0,1\\src\\binary128\\internal\\cs\\Leb128.hx"
				while (true) {
					#line 34 "C:\\HaxeToolkit\\haxe\\lib\\binary128\\0,0,1\\src\\binary128\\internal\\cs\\Leb128.hx"
					long bt = ((long) (( @value & 127 )) );
					@value = ((long) (( @value >> 7 )) );
					#line 36 "C:\\HaxeToolkit\\haxe\\lib\\binary128\\0,0,1\\src\\binary128\\internal\\cs\\Leb128.hx"
					more =  ! ((( ( ( @value == 0 ) && ( (((long) (( bt & 64 )) )) == 0 ) ) || ( ( @value == -1 ) && ( (((long) (( bt & 64 )) )) != 0 ) ) ))) ;
					#line 38 "C:\\HaxeToolkit\\haxe\\lib\\binary128\\0,0,1\\src\\binary128\\internal\\cs\\Leb128.hx"
					if (more) {
						#line 38 "C:\\HaxeToolkit\\haxe\\lib\\binary128\\0,0,1\\src\\binary128\\internal\\cs\\Leb128.hx"
						bt = ((long) (( bt | 128 )) );
					}
					
					#line 39 "C:\\HaxeToolkit\\haxe\\lib\\binary128\\0,0,1\\src\\binary128\\internal\\cs\\Leb128.hx"
					buf.writeByte(((int) (bt) ));
					#line 33 "C:\\HaxeToolkit\\haxe\\lib\\binary128\\0,0,1\\src\\binary128\\internal\\cs\\Leb128.hx"
					if ( ! (more) ) {
						#line 33 "C:\\HaxeToolkit\\haxe\\lib\\binary128\\0,0,1\\src\\binary128\\internal\\cs\\Leb128.hx"
						break;
					}
					
				}
				
			}
			#line default
		}
		
		
		public static void writeSigned32LEB128(global::haxe.io.BytesOutput buf, int @value) {
			unchecked {
				#line 44 "C:\\HaxeToolkit\\haxe\\lib\\binary128\\0,0,1\\src\\binary128\\internal\\cs\\Leb128.hx"
				bool more = false;
				#line 46 "C:\\HaxeToolkit\\haxe\\lib\\binary128\\0,0,1\\src\\binary128\\internal\\cs\\Leb128.hx"
				while (true) {
					#line 47 "C:\\HaxeToolkit\\haxe\\lib\\binary128\\0,0,1\\src\\binary128\\internal\\cs\\Leb128.hx"
					int bt = ((int) (( @value & 127 )) );
					@value = ((int) (( @value >> 7 )) );
					#line 49 "C:\\HaxeToolkit\\haxe\\lib\\binary128\\0,0,1\\src\\binary128\\internal\\cs\\Leb128.hx"
					more =  ! ((( ( ((bool) (( @value == 0 )) ) && ((bool) (( (((int) (( bt & 64 )) )) == 0 )) ) ) || ( ((bool) (( @value == -1 )) ) && ((bool) (( (((int) (( bt & 64 )) )) != 0 )) ) ) ))) ;
					#line 51 "C:\\HaxeToolkit\\haxe\\lib\\binary128\\0,0,1\\src\\binary128\\internal\\cs\\Leb128.hx"
					if (more) {
						#line 51 "C:\\HaxeToolkit\\haxe\\lib\\binary128\\0,0,1\\src\\binary128\\internal\\cs\\Leb128.hx"
						bt = ((int) (( bt | 128 )) );
					}
					
					#line 52 "C:\\HaxeToolkit\\haxe\\lib\\binary128\\0,0,1\\src\\binary128\\internal\\cs\\Leb128.hx"
					buf.writeByte(((int) (bt) ));
					#line 46 "C:\\HaxeToolkit\\haxe\\lib\\binary128\\0,0,1\\src\\binary128\\internal\\cs\\Leb128.hx"
					if ( ! (more) ) {
						#line 46 "C:\\HaxeToolkit\\haxe\\lib\\binary128\\0,0,1\\src\\binary128\\internal\\cs\\Leb128.hx"
						break;
					}
					
				}
				
			}
			#line default
		}
		
		
		public static void writeUnsigned64LEB128(global::haxe.io.BytesOutput buf, ulong @value) {
			unchecked {
				#line 57 "C:\\HaxeToolkit\\haxe\\lib\\binary128\\0,0,1\\src\\binary128\\internal\\cs\\Leb128.hx"
				while (true) {
					#line 58 "C:\\HaxeToolkit\\haxe\\lib\\binary128\\0,0,1\\src\\binary128\\internal\\cs\\Leb128.hx"
					ulong bt = ((ulong) (( @value & 127 )) );
					@value = ((ulong) (( @value >> 7 )) );
					#line 60 "C:\\HaxeToolkit\\haxe\\lib\\binary128\\0,0,1\\src\\binary128\\internal\\cs\\Leb128.hx"
					if (( @value != 0 )) {
						#line 60 "C:\\HaxeToolkit\\haxe\\lib\\binary128\\0,0,1\\src\\binary128\\internal\\cs\\Leb128.hx"
						bt = ((ulong) (( bt | 128 )) );
					}
					
					#line 61 "C:\\HaxeToolkit\\haxe\\lib\\binary128\\0,0,1\\src\\binary128\\internal\\cs\\Leb128.hx"
					buf.writeByte(((int) (bt) ));
					#line 57 "C:\\HaxeToolkit\\haxe\\lib\\binary128\\0,0,1\\src\\binary128\\internal\\cs\\Leb128.hx"
					if ( ! ((( @value != 0 ))) ) {
						#line 57 "C:\\HaxeToolkit\\haxe\\lib\\binary128\\0,0,1\\src\\binary128\\internal\\cs\\Leb128.hx"
						break;
					}
					
				}
				
			}
			#line default
		}
		
		
		public static void writeUnsigned32LEB128(global::haxe.io.BytesOutput buf, uint @value) {
			unchecked {
				#line 66 "C:\\HaxeToolkit\\haxe\\lib\\binary128\\0,0,1\\src\\binary128\\internal\\cs\\Leb128.hx"
				while (true) {
					#line 67 "C:\\HaxeToolkit\\haxe\\lib\\binary128\\0,0,1\\src\\binary128\\internal\\cs\\Leb128.hx"
					uint bt = ((uint) (( @value & 127 )) );
					@value = ((uint) (((uint) (( ((uint) (@value) ) >> 7 )) )) );
					#line 69 "C:\\HaxeToolkit\\haxe\\lib\\binary128\\0,0,1\\src\\binary128\\internal\\cs\\Leb128.hx"
					if (((bool) (( @value != 0 )) )) {
						#line 69 "C:\\HaxeToolkit\\haxe\\lib\\binary128\\0,0,1\\src\\binary128\\internal\\cs\\Leb128.hx"
						bt = ((uint) (( bt | 128 )) );
					}
					
					#line 70 "C:\\HaxeToolkit\\haxe\\lib\\binary128\\0,0,1\\src\\binary128\\internal\\cs\\Leb128.hx"
					buf.writeByte(((int) (bt) ));
					#line 66 "C:\\HaxeToolkit\\haxe\\lib\\binary128\\0,0,1\\src\\binary128\\internal\\cs\\Leb128.hx"
					if ( ! ((((bool) (( @value != 0 )) ))) ) {
						#line 66 "C:\\HaxeToolkit\\haxe\\lib\\binary128\\0,0,1\\src\\binary128\\internal\\cs\\Leb128.hx"
						break;
					}
					
				}
				
			}
			#line default
		}
		
		
		public static uint readSignedLEB128(global::haxe.io.BytesInput buf) {
			unchecked {
				#line 75 "C:\\HaxeToolkit\\haxe\\lib\\binary128\\0,0,1\\src\\binary128\\internal\\cs\\Leb128.hx"
				int bt = 0;
				#line 77 "C:\\HaxeToolkit\\haxe\\lib\\binary128\\0,0,1\\src\\binary128\\internal\\cs\\Leb128.hx"
				uint @value = ((uint) (0) );
				int shift = 0;
				#line 80 "C:\\HaxeToolkit\\haxe\\lib\\binary128\\0,0,1\\src\\binary128\\internal\\cs\\Leb128.hx"
				while (true) {
					#line 81 "C:\\HaxeToolkit\\haxe\\lib\\binary128\\0,0,1\\src\\binary128\\internal\\cs\\Leb128.hx"
					int ibt = buf.readByte();
					if (( ibt < 0 )) {
						#line 82 "C:\\HaxeToolkit\\haxe\\lib\\binary128\\0,0,1\\src\\binary128\\internal\\cs\\Leb128.hx"
						throw global::haxe.lang.HaxeException.wrap("LEB128.ReadSLEB128(premature stream end)");
					}
					
					#line 83 "C:\\HaxeToolkit\\haxe\\lib\\binary128\\0,0,1\\src\\binary128\\internal\\cs\\Leb128.hx"
					bt = ibt;
					#line 85 "C:\\HaxeToolkit\\haxe\\lib\\binary128\\0,0,1\\src\\binary128\\internal\\cs\\Leb128.hx"
					@value = ((uint) (( @value | ( (( bt & 127 )) << shift ) )) );
					shift += 7;
					#line 80 "C:\\HaxeToolkit\\haxe\\lib\\binary128\\0,0,1\\src\\binary128\\internal\\cs\\Leb128.hx"
					if ( ! ((( bt >= 128 ))) ) {
						#line 80 "C:\\HaxeToolkit\\haxe\\lib\\binary128\\0,0,1\\src\\binary128\\internal\\cs\\Leb128.hx"
						break;
					}
					
				}
				
				#line 90 "C:\\HaxeToolkit\\haxe\\lib\\binary128\\0,0,1\\src\\binary128\\internal\\cs\\Leb128.hx"
				if (( (( bt & 64 )) != 0 )) {
					#line 91 "C:\\HaxeToolkit\\haxe\\lib\\binary128\\0,0,1\\src\\binary128\\internal\\cs\\Leb128.hx"
					@value = ((uint) (( @value | ( -1L << shift ) )) );
				}
				
				#line 94 "C:\\HaxeToolkit\\haxe\\lib\\binary128\\0,0,1\\src\\binary128\\internal\\cs\\Leb128.hx"
				return @value;
			}
			#line default
		}
		
		
		public static int readUnsignedLEB128(global::haxe.io.BytesInput buf) {
			unchecked {
				#line 98 "C:\\HaxeToolkit\\haxe\\lib\\binary128\\0,0,1\\src\\binary128\\internal\\cs\\Leb128.hx"
				int @value = 0;
				#line 100 "C:\\HaxeToolkit\\haxe\\lib\\binary128\\0,0,1\\src\\binary128\\internal\\cs\\Leb128.hx"
				int shift = 0;
				#line 102 "C:\\HaxeToolkit\\haxe\\lib\\binary128\\0,0,1\\src\\binary128\\internal\\cs\\Leb128.hx"
				while (true) {
					#line 103 "C:\\HaxeToolkit\\haxe\\lib\\binary128\\0,0,1\\src\\binary128\\internal\\cs\\Leb128.hx"
					int bt = buf.readByte();
					if (( bt < 0 )) {
						#line 104 "C:\\HaxeToolkit\\haxe\\lib\\binary128\\0,0,1\\src\\binary128\\internal\\cs\\Leb128.hx"
						throw global::haxe.lang.HaxeException.wrap("LEB128.ReadULEB128(premature stream end)");
					}
					
					#line 106 "C:\\HaxeToolkit\\haxe\\lib\\binary128\\0,0,1\\src\\binary128\\internal\\cs\\Leb128.hx"
					@value += ( (( bt & 127 )) << shift );
					#line 108 "C:\\HaxeToolkit\\haxe\\lib\\binary128\\0,0,1\\src\\binary128\\internal\\cs\\Leb128.hx"
					if (( bt < 128 )) {
						#line 108 "C:\\HaxeToolkit\\haxe\\lib\\binary128\\0,0,1\\src\\binary128\\internal\\cs\\Leb128.hx"
						break;
					}
					
					#line 110 "C:\\HaxeToolkit\\haxe\\lib\\binary128\\0,0,1\\src\\binary128\\internal\\cs\\Leb128.hx"
					shift += 7;
				}
				
				#line 113 "C:\\HaxeToolkit\\haxe\\lib\\binary128\\0,0,1\\src\\binary128\\internal\\cs\\Leb128.hx"
				return @value;
			}
			#line default
		}
		
		
	}
}


