// Generated by Haxe 4.1.0-rc.1+0d88c583b
using haxe.root;

#pragma warning disable 109, 114, 219, 429, 168, 162
namespace haxe.lang {
	public sealed class FieldHashConflict {
		
		public FieldHashConflict(int hash, string name, object @value, global::haxe.lang.FieldHashConflict next) {
			this.hash = hash;
			this.name = name;
			this.@value = @value;
			this.next = next;
		}
		
		
		public readonly int hash;
		
		public readonly string name;
		
		public object @value;
		
		public global::haxe.lang.FieldHashConflict next;
		
	}
}



#pragma warning disable 109, 114, 219, 429, 168, 162
namespace haxe.lang {
	public sealed class FieldLookup {
		
		#pragma warning disable 628
		static FieldLookup() {
			global::haxe.lang.FieldLookup.length = ( global::haxe.lang.FieldLookup.fieldIds as global::System.Array ).Length;
		}
		
		
		public FieldLookup() {
		}
		
		
		protected static int[] fieldIds = new int[]{97, 98, 99, 102, 104, 105, 107, 109, 111, 113, 115, 116, 118, 17501, 17508, 21680, 21681, 22416, 22848, 22853, 22862, 23072, 23296, 23515, 23520, 23527, 23533, 23977, 24863, 1332402, 1821933, 3217576, 3804260, 4745537, 4846113, 4849249, 4899635, 4947578, 4947588, 4948692, 4949376, 4995541, 4996429, 5047484, 5049505, 5144726, 5145602, 5194459, 5243965, 5246186, 5343647, 5393365, 5442204, 5442212, 5443986, 5446660, 5541879, 5542767, 5591400, 5594513, 5594516, 5691732, 5693967, 5695307, 5741474, 5741478, 5744817, 5745024, 5790526, 5841808, 5843820, 9671866, 10319920, 12898935, 13816588, 23388265, 24046298, 25738091, 33044624, 33885760, 42482904, 42740551, 43737796, 46374763, 46969062, 52644165, 57219237, 58524531, 66083509, 67859554, 67859985, 68006728, 69677120, 72252782, 76061764, 79259656, 81457683, 87367608, 89107268, 94306131, 95523933, 96903864, 100394802, 112735659, 116192081, 117638261, 117802505, 125111323, 127488538, 127579341, 132916898, 133414859, 140313464, 142151465, 142301684, 142895325, 156956385, 157772329, 158986576, 159136996, 165491232, 172955042, 179047623, 184980232, 188431961, 197623819, 207600192, 207609411, 208459108, 209783238, 209784577, 216674036, 222029606, 226403973, 226931207, 234584065, 243225909, 244830897, 246644057, 247056493, 247727401, 252173918, 252174139, 252174360, 252175031, 253048465, 257783349, 261031087, 262801146, 271957957, 271957958, 281751194, 283737885, 288167040, 293985672, 297493355, 298394930, 299197528, 302979532, 305151978, 305918609, 309502035, 311106773, 311106994, 317495956, 328837820, 328878574, 334695532, 336655392, 341784511, 342296321, 343868310, 347970898, 350619104, 350619108, 353204262, 358990357, 359333139, 360725482, 363100693, 365188593, 373703110, 388680308, 390269249, 391692349, 400509660, 400657953, 401430337, 401708611, 402568708, 404153790, 407283053, 414206607, 437335495, 451001976, 452737314, 457862913, 460944723, 467569146, 467974121, 474209209, 474773467, 477978468, 480756972, 481768284, 486578026, 488637228, 493819893, 499574632, 501039929, 502768344, 502769015, 520590566, 520665567, 528448451, 529665746, 542823803, 544309738, 548230639, 557884804, 563366437, 563373605, 567946016, 572311959, 588879225, 588902871, 589000550, 589599061, 590345008, 591404329, 593395418, 596483356, 596855981, 597301535, 602959184, 603155197, 605915487, 610723709, 610977416, 614073432, 620069381, 624660685, 625308696, 627260031, 633519755, 640252688, 645255902, 650414942, 651552891, 651890926, 652994848, 653138191, 663976354, 666085479, 666925948, 688014215, 692852915, 694510256, 701410669, 703544457, 704967423, 708366590, 709377715, 722956077, 724060212, 735461151, 740165228, 740342846, 742854407, 755154371, 762525219, 772311838, 772312059, 772312280, 779384562, 780426091, 784433846, 790737991, 796168079, 798719589, 802695958, 834174833, 845179051, 850878155, 851061127, 855935792, 867683501, 875792495, 875946231, 877441228, 878103594, 887376854, 888664408, 889051340, 910198946, 914379062, 916448704, 920765674, 922037898, 922671056, 930986349, 930987020, 934865761, 937267591, 938763356, 939359644, 941286177, 946786476, 952878022, 961933062, 974697390, 978413626, 988470062, 993950564, 995006396, 1008163129, 1021796563, 1041537810, 1042138122, 1042491189, 1044656577, 1053199141, 1057738399, 1058556349, 1058852512, 1059352685, 1064807522, 1066567601, 1067353468, 1071652316, 1072885311, 1084680072, 1091627025, 1092023741, 1092025094, 1092171829, 1092614307, 1100132261, 1102715038, 1103060696, 1103264054, 1103409453, 1103412149, 1106197222, 1106494318, 1110774469, 1113806378, 1113806382, 1114204006, 1115112725, 1122566364, 1126038837, 1126920507, 1134303404, 1136381564, 1136381571, 1136978756, 1148821524, 1151917883, 1152047462, 1154061571, 1154932936, 1155848147, 1158359328, 1158860648, 1169898256, 1169995914, 1170139280, 1170195731, 1171620962, 1181009664, 1181037546, 1190344133, 1191628933, 1191633396, 1191829406, 1202522710, 1202718727, 1202920542, 1204059472, 1204816148, 1205545654, 1212528822, 1213433212, 1213610478, 1213952393, 1213952397, 1214305123, 1214452573, 1214453688, 1216737445, 1221600027, 1224228525, 1224700491, 1224901644, 1224901875, 1225098545, 1227765365, 1230265810, 1238832007, 1241114938, 1242623863, 1244352339, 1247076770, 1247576961, 1247723251, 1247875546, 1257164128, 1257939113, 1265845817, 1269206179, 1269254998, 1269755419, 1269755426, 1271070480, 1275922997, 1276009546, 1280344581, 1280345464, 1280347464, 1280549057, 1280638028, 1280638699, 1280842308, 1280845662, 1281093634, 1282943179, 1291436593, 1291439277, 1291635725, 1292432058, 1300511267, 1302870512, 1309344294, 1310130144, 1311059210, 1312666830, 1313416818, 1315911912, 1320836033, 1324505717, 1324703024, 1337394146, 1348037855, 1351924992, 1352786672, 1361240459, 1373340450, 1381630732, 1382589827, 1384944624, 1386805980, 1390395051, 1390578741, 1390578962, 1390579183, 1390579854, 1395555037, 1395946515, 1400771174, 1415277398, 1422715602, 1424504384, 1425796404, 1428421673, 1433765834, 1434363216, 1450762973, 1451561102, 1453881019, 1457020077, 1461444633, 1462163331, 1480586310, 1484998194, 1486625537, 1491961287, 1499729668, 1503920168, 1528381236, 1532710347, 1533460349, 1537812987, 1538685534, 1542393958, 1547539107, 1554247961, 1576149820, 1577180160, 1581035319, 1587590681, 1596686527, 1601245343, 1601313232, 1603224798, 1614780307, 1617751537, 1620824029, 1621420777, 1623148745, 1627978226, 1631127864, 1633074023, 1639293562, 1641182320, 1648581351, 1651365158, 1655151068, 1661457477, 1661489734, 1678020492, 1678440898, 1688768510, 1692511090, 1693277486, 1695321753, 1705629508, 1707675189, 1723805383, 1724402127, 1738878153, 1757798127, 1763375486, 1765542170, 1768164316, 1779076515, 1783198826, 1786603393, 1787083615, 1789423016, 1794072594, 1795947670, 1797611211, 1800886518, 1806782403, 1815533258, 1816005769, 1816119224, 1819568762, 1825556557, 1828505873, 1830310359, 1835399246, 1837892969, 1840455391, 1860333403, 1864494649, 1870153642, 1873474154, 1878640711, 1887398975, 1887596712, 1889717695, 1891834246, 1894423562, 1895567566, 1898155939, 1900716655, 1900901265, 1902382029, 1910689201, 1910809482, 1915412854, 1916009602, 1920533415, 1937159360, 1941397386, 1963552417, 1970444429, 1975830554, 1981972957, 1983511113, 1987492451, 1997218321, 2005096905, 2005380545, 2010580328, 2012934199, 2015619911, 2022294396, 2025055113, 2025238049, 2027665272, 2029008698, 2033429251, 2035606524, 2043067981, 2044981782, 2048392659, 2050190630, 2052882457, 2053879230, 2054470699, 2062888707, 2063350530, 2068579297, 2070371531, 2075401505, 2076642473, 2079583163, 2079633382, 2081384188, 2082663554, 2083500811, 2088117657, 2098590048, 2102473875, 2103468489, 2104336224, 2113708439, 2123232567, 2124012840, 2124851751, 2126608787, 2127021138, 2127021361, 2131139013, 2131919360, 2132884806, 2132884807};
		
		protected static string[] fields = new string[]{"a", "b", "c", "f", "h", "i", "k", "m", "o", "q", "s", "t", "v", "Nk", "Nr", "a1", "a2", "dt", "ff", "fk", "ft", "gg", "hh", "id", "ii", "ip", "iv", "kt", "on", "get_position", "isGlobal", "encryptBlock", "Log", "__a", "add", "arr", "buf", "cmd", "cmn", "crc", "cur", "dev", "dir", "eof", "ext", "get", "gid", "hex", "idx", "ino", "key", "len", "map", "max", "min", "mul", "obj", "off", "pay", "pop", "pos", "reg", "rol", "run", "set", "sex", "str", "sub", "tbl", "uid", "uri", "field", "first", "inGame", "SuppressWarnings", "onopen", "split", "exitCode", "dispatchEventWithThread", "writeBinary", "removeListener", "flags", "flush", "readAll", "readMap", "match", "compare", "huffdist", "addLine", "start", "state", "stdin", "isDefaultPrevented", "helper", "remove", "earnMoney", "getResult", "filter", "readUnsignedInt", "__isCanceledNow", "decodeBytes", "merge", "status", "transEventHall", "target", "resetBits", "update", "hashCode", "waitCount", "lengths", "stderr", "stdout", "__targetDispatcher", "classString", "resize", "result", "method", "onError", "removeFrmClubC", "matched", "isRobot", "getFullYear", "readString", "accept", "getHours", "dataSize", "money", "isEmpty", "parseString", "outpos", "output", "hasEventListener", "setLoop", "_length", "getString", "doEncode", "readBytes", "compareArg", "gailv", "_opcode", "scoreTip", "readInt16", "readInt24", "readInt32", "readInt64", "getUTCMinutes", "makeWSKey", "get_length", "mtime", "timer", "times", "setFloat", "writeShort", "stream", "releaseCount", "onCMDResultC", "addRoundKey", "onBeBankerC", "methodName", "hostEntry", "clubID", "setDouble", "readUInt16", "readUInt24", "onDispath", "getBits", "iterator", "indent", "toHex", "isBlocking", "tryToBeBankerC", "dateUTC", "_socket", "getData", "getDate", "set_position", "getUInt16", "lastIndexOf", "connect", "checkCode", "getUTCSeconds", "active", "nbits", "changeStatusC", "writeFloat", "totlen", "totoal", "roomMap", "peekByte", "roomdID", "replacer", "hasNext", "sendHandshake", "message", "keysLoop", "reverse", "maxBiling", "_lastError", "canGetMoney", "__preventDefault", "addme", "tryAcquire", "onJoinRoom", "nOccupied", "parseNumber", "subWord", "isFinal", "getBytes", "nlink", "insert", "getInt32", "getInt64", "length", "addSub", "getTime", "transEvent", "bigEndian", "stopPropagation", "canChangingStatus", "addEventListner", "openID", "openid", "treeCompress", "native", "onGET_ROOM_INFOC", "getBit", "getDay", "getPid", "get_ip", "getMinutes", "_processThread", "balance", "resultLostMoeny", "resultLostMoney", "writeInt", "writeMap", "sendMessage", "writeFullBytes", "onmessage", "matchedRight", "onUpdateRoomUsers", "_lastPong", "nextRun", "addDistOne", "inflateLoop", "writeString", "initTable", "set_bigEndian", "unReg", "atime", "invalidNumber", "_payload", "__removeAllListeners", "buildFixedHuffman", "getUTCDate", "encodeString", "htools", "owerID", "invalidChar", "getSeconds", "useCapture", "writeObject", "isBanker", "huffman", "replace", "setTimeout", "treeMake", "searchRoomID", "readDouble", "checksum", "__formatToString", "writeUInt16", "writeUInt24", "writeUInt32", "invMixColumns", "resultEarnMoney", "pretty", "getDouble", "heardTimder", "encrypt", "wasAddEventListener", "value", "quotient", "subBytes", "treeWalk", "bitOR", "_socketAsyncEventArgs", "recvHttpResponse", "handshake", "lockObj", "fieldsString", "acquire", "bling", "messages", "compareArgs", "onCreateRoom", "decryptBlock", "_wasLeaving", "addBytes", "cachedIndex", "addInt32", "addInt64", "player", "prepare", "handerAndPlayer", "hander", "canBet", "toString", "setFastSend", "inflateLengths", "activeObjects", "writeArray", "build", "priority", "hashes", "onLoginC", "releaseEvent", "index", "input", "subCmdID", "eventPhase", "joinRoom", "_buffer", "_eof", "_key", "_uri", "mobile", "custom", "splice", "exists", "equals", "_partialLength", "base", "bind", "bits", "blit", "cards", "__iterators", "call", "chat", "club", "code", "copy", "userID", "phone", "treeDepth", "data", "date", "dist", "readLinesUntil", "invSubBytes", "expr", "matchSub", "currentOffset", "file", "fill", "func", "cancelable", "storage", "chunks", "peekUntil", "removeLoop", "minBinding", "head", "host", "init", "ipad", "isGM", "item", "getTimezoneOffset", "dispatchEvent", "join", "sendFrame", "keep", "keys", "kill", "last", "left", "list", "writeDouble", "concat", "roomID", "backslash", "playerID", "make", "clean", "clear", "mode", "clone", "close", "_onopenCalled", "password", "readAllAvailableBytes", "name", "newl", "next", "nind", "encodeBytes", "addString", "writeByte", "_acceptedSockets", "setBlocking", "timeToClient", "peer", "port", "prev", "push", "keyValueIterator", "position", "onclose", "rdev", "read", "room", "root", "matchedPos", "execute", "get_size", "seat", "seek", "send", "size", "setInt32", "setInt64", "sock", "sort", "stop", "quicksort", "tell", "text", "time", "type", "gamesDLL", "ctime", "readFullBytes", "__dispatchEvent", "waitForRead", "getUTCDay", "vals", "writeInt8", "totalResult", "wait", "webD", "values", "write", "buffer", "spliceVoid", "roomCard", "onStatusChangeC", "writeBytes", "__isCanceled", "window", "messageVer", "writeInput", "writeInt16", "writeInt24", "writeInt32", "writeInt64", "cachedKey", "getRevBits", "readFloat", "onErrorFromServer", "onCreateClubC", "convertDataToPacket", "onAddBetC", "roomInfo", "removeEventListener", "__addListenerByPriority", "parseRec", "oneByte", "shiftRows", "_isFinal", "roomList", "delay", "willTrigger", "getUTCMonth", "__getInactive", "release", "onAcceptCompleted", "objString", "_isMasked", "concatNative", "stopImmediatePropagation", "nBuckets", "endsWith", "referenceID", "className", "_frameIsBinary", "quote", "onGetRoomInfo", "createRoom", "onClose", "isCopy", "decodeString", "_encodedKey", "money_clone", "offset", "roundKey", "__unsafe_get", "__unsafe_set", "indexOf", "handleData", "getBlockSize", "bubbles", "lookup", "httpVersion", "fileName", "getFloat", "mainCmdID", "setFlushMode", "headers", "__addInactive", "__eventMap", "getLeaving", "iteratorLoop", "decode", "processThread", "toDynamic", "needed", "regex", "reset", "preventDefault", "__removeInactive", "readByte", "onRoomDestory", "right", "errorID", "currentTarget", "rotWord", "applyHuffman", "canSeek", "addDouble", "shutdown", "getDefault", "results", "writeMapLength", "getMonth", "onOpen", "sPath", "oriMoney", "decrypt", "readMessage", "customParams", "round", "nextChar", "readInt8", "binaryType", "addEvent", "set_iv", "readLine", "listen", "sendHttpRequest", "doParse", "get_canSeek", "_height", "bitAND", "bitXOR", "others", "process", "sendHttpResponse", "addEventListener", "createClubC", "invShiftRows", "__get", "__set", "nick_name", "__hx_deleteField", "reConnectSocket", "mixColumns", "ipAddress", "event", "lineNumber", "onerror", "readArray", "readUnsignedShort", "available", "getUTCHours", "readUntil", "modulus", "_host", "upperBound", "unshift", "setUInt16", "scroe", "getUTCFullYear", "formatToString", "__pool", "onCreateRoomC", "encode", "_keys", "prepareFrame", "avatar", "set_size", "loseMoney", "currentData", "getLastChar", "__size", "_mask", "recvHttpRequest", "inactiveObjects", "addFloat", "setUpRoomInfo", "create", "shift", "matchedLeft", "getClubListC", "keyExpansion", "addBetC", "addByte", "_port", "addChar", "removeMinBinding", "__inactiveObjectList", "addDist", "onLeaveRoom", "slice", "slide", "callback", "sendCommandC", "__inactiveObject0", "__inactiveObject1"};
		
		protected static int length;
		
		public static void addFields(int[] nids, string[] nfields) {
			unchecked {
				int[] cids = global::haxe.lang.FieldLookup.fieldIds;
				string[] cfields = global::haxe.lang.FieldLookup.fields;
				int nlen = ( nids as global::System.Array ).Length;
				int clen = global::haxe.lang.FieldLookup.length;
				if (( ( nfields as global::System.Array ).Length != nlen )) {
					throw global::haxe.lang.HaxeException.wrap(global::haxe.lang.Runtime.concat(global::haxe.lang.Runtime.concat(global::haxe.lang.Runtime.concat("Different fields length: ", global::haxe.lang.Runtime.toString(nlen)), " and "), global::haxe.lang.Runtime.toString(( nfields as global::System.Array ).Length)));
				}
				
				bool needsChange = false;
				{
					int[] _g_arr = nids;
					uint _g_idx = ((uint) (0) );
					while (((bool) (( _g_idx < ( _g_arr as global::System.Array ).Length )) )) {
						_g_idx += ((uint) (1) );
						int i = ((int) (_g_arr[((int) (((uint) (( _g_idx - 1 )) )) )]) );
						if (( global::haxe.lang.FieldLookup.findHash(i, cids, clen) < 0 )) {
							needsChange = true;
							break;
						}
						
					}
					
				}
				
				if (needsChange) {
					lock(typeof(global::haxe.lang.FieldLookup)){
						int[] ansIds = new int[( clen + nlen )];
						string[] ansFields = new string[( clen + nlen )];
						int ci = 0;
						int ni = 0;
						int ansi = 0;
						while (true) {
							if ( ! ((( (( ci < clen )) ? (( ni < nlen )) : (false) ))) ) {
								break;
							}
							
							if (( ((int) (cids[ci]) ) < ((int) (nids[ni]) ) )) {
								ansIds[ansi] = ((int) (cids[ci]) );
								ansFields[ansi] = ((string) (cfields[ci]) );
								ci = ( ci + 1 );
							}
							else {
								ansIds[ansi] = ((int) (nids[ni]) );
								ansFields[ansi] = ((string) (nfields[ni]) );
								ni = ( ni + 1 );
							}
							
							ansi = ( ansi + 1 );
						}
						
						if (( ci < clen )) {
							global::System.Array.Copy(((global::System.Array) (cids) ), ((int) (ci) ), ((global::System.Array) (ansIds) ), ((int) (ansi) ), ((int) (( clen - ci )) ));
							global::System.Array.Copy(((global::System.Array) (cfields) ), ((int) (ci) ), ((global::System.Array) (ansFields) ), ((int) (ansi) ), ((int) (( clen - ci )) ));
							ansi = ( ansi + (( clen - ci )) );
						}
						
						if (( ni < nlen )) {
							global::System.Array.Copy(((global::System.Array) (nids) ), ((int) (ni) ), ((global::System.Array) (ansIds) ), ((int) (ansi) ), ((int) (( nlen - ni )) ));
							global::System.Array.Copy(((global::System.Array) (nfields) ), ((int) (ni) ), ((global::System.Array) (ansFields) ), ((int) (ansi) ), ((int) (( nlen - ni )) ));
							ansi = ( ansi + (( nlen - ni )) );
						}
						
						global::haxe.lang.FieldLookup.fieldIds = ansIds;
						global::haxe.lang.FieldLookup.fields = ansFields;
						global::haxe.lang.FieldLookup.length = ansi;
					}
					;
				}
				
			}
		}
		
		
		public static int doHash(string s) {
			unchecked {
				int acc = 0;
				{
					int _g = 0;
					int _g1 = s.Length;
					while (( _g < _g1 )) {
						int i = _g++;
						acc = ( ( ( 223 * (( acc >> 1 )) ) + ((int) (s[i]) ) ) << 1 );
					}
					
				}
				
				return ((int) (( ((uint) (acc) ) >> 1 )) );
			}
		}
		
		
		public static string lookupHash(int key) {
			unchecked {
				int[] ids = global::haxe.lang.FieldLookup.fieldIds;
				int min = 0;
				int max = global::haxe.lang.FieldLookup.length;
				while (( min < max )) {
					int mid = ( min + ( (( max - min )) / 2 ) );
					int imid = ((int) (ids[mid]) );
					if (( key < imid )) {
						max = mid;
					}
					else if (( key > imid )) {
						min = ( mid + 1 );
					}
					else {
						return ((string) (global::haxe.lang.FieldLookup.fields[mid]) );
					}
					
				}
				
				throw global::haxe.lang.HaxeException.wrap(global::haxe.lang.Runtime.concat("Field not found for hash ", global::haxe.lang.Runtime.toString(key)));
			}
		}
		
		
		public static int hash(string s) {
			unchecked {
				if (( s == null )) {
					return 0;
				}
				
				int acc = 0;
				{
					int _g = 0;
					int _g1 = s.Length;
					while (( _g < _g1 )) {
						int i = _g++;
						acc = ( ( ( 223 * (( acc >> 1 )) ) + ((int) (s[i]) ) ) << 1 );
					}
					
				}
				
				int key = ((int) (( ((uint) (acc) ) >> 1 )) );
				int[] ids = global::haxe.lang.FieldLookup.fieldIds;
				string[] fld = global::haxe.lang.FieldLookup.fields;
				int min = 0;
				int max = global::haxe.lang.FieldLookup.length;
				int len = global::haxe.lang.FieldLookup.length;
				while (( min < max )) {
					int mid = ((int) (( min + ( ((double) ((( max - min ))) ) / 2 ) )) );
					int imid = ((int) (ids[mid]) );
					if (( key < imid )) {
						max = mid;
					}
					else if (( key > imid )) {
						min = ( mid + 1 );
					}
					else {
						string field = ((string) (fld[mid]) );
						if (( field != s )) {
							return  ~ (key) ;
						}
						
						return key;
					}
					
				}
				
				lock(typeof(global::haxe.lang.FieldLookup)){
					if (( len != global::haxe.lang.FieldLookup.length )) {
						return global::haxe.lang.FieldLookup.hash(s);
					}
					
					global::haxe.lang.FieldLookup.fieldIds = global::haxe.lang.FieldLookup.insertInt(global::haxe.lang.FieldLookup.fieldIds, global::haxe.lang.FieldLookup.length, min, key);
					global::haxe.lang.FieldLookup.fields = global::haxe.lang.FieldLookup.insertString(global::haxe.lang.FieldLookup.fields, global::haxe.lang.FieldLookup.length, min, s);
					 ++ global::haxe.lang.FieldLookup.length;
				}
				;
				return key;
			}
		}
		
		
		public static int findHash(int hash, int[] hashs, int length) {
			unchecked {
				int min = 0;
				int max = length;
				while (( min < max )) {
					int mid = ( (( max + min )) / 2 );
					int imid = ((int) (hashs[mid]) );
					if (( hash < imid )) {
						max = mid;
					}
					else if (( hash > imid )) {
						min = ( mid + 1 );
					}
					else {
						return mid;
					}
					
				}
				
				return  ~ (min) ;
			}
		}
		
		
		public static void removeInt(int[] a, int length, int pos) {
			unchecked {
				global::System.Array.Copy(((global::System.Array) (a) ), ((int) (( pos + 1 )) ), ((global::System.Array) (a) ), ((int) (pos) ), ((int) (( ( length - pos ) - 1 )) ));
				a[( length - 1 )] = 0;
			}
		}
		
		
		public static void removeFloat(double[] a, int length, int pos) {
			unchecked {
				global::System.Array.Copy(((global::System.Array) (a) ), ((int) (( pos + 1 )) ), ((global::System.Array) (a) ), ((int) (pos) ), ((int) (( ( length - pos ) - 1 )) ));
				a[( length - 1 )] = ((double) (0) );
			}
		}
		
		
		public static void removeDynamic(object[] a, int length, int pos) {
			unchecked {
				global::System.Array.Copy(((global::System.Array) (a) ), ((int) (( pos + 1 )) ), ((global::System.Array) (a) ), ((int) (pos) ), ((int) (( ( length - pos ) - 1 )) ));
				a[( length - 1 )] = null;
			}
		}
		
		
		public static int[] insertInt(int[] a, int length, int pos, int x) {
			unchecked {
				int[] a1 = a;
				int capacity = ( a1 as global::System.Array ).Length;
				if (( pos == length )) {
					if (( capacity == length )) {
						int[] newarr = new int[( (( length << 1 )) + 1 )];
						( a1 as global::System.Array ).CopyTo(((global::System.Array) (newarr) ), ((int) (0) ));
						a1 = newarr;
					}
					
				}
				else if (( pos == 0 )) {
					if (( capacity == length )) {
						int[] newarr1 = new int[( (( length << 1 )) + 1 )];
						global::System.Array.Copy(((global::System.Array) (a1) ), ((int) (0) ), ((global::System.Array) (newarr1) ), ((int) (1) ), ((int) (length) ));
						a1 = newarr1;
					}
					else {
						global::System.Array.Copy(((global::System.Array) (a1) ), ((int) (0) ), ((global::System.Array) (a1) ), ((int) (1) ), ((int) (length) ));
					}
					
				}
				else if (( capacity == length )) {
					int[] newarr2 = new int[( (( length << 1 )) + 1 )];
					global::System.Array.Copy(((global::System.Array) (a1) ), ((int) (0) ), ((global::System.Array) (newarr2) ), ((int) (0) ), ((int) (pos) ));
					global::System.Array.Copy(((global::System.Array) (a1) ), ((int) (pos) ), ((global::System.Array) (newarr2) ), ((int) (( pos + 1 )) ), ((int) (( length - pos )) ));
					a1 = newarr2;
				}
				else {
					global::System.Array.Copy(((global::System.Array) (a1) ), ((int) (pos) ), ((global::System.Array) (a1) ), ((int) (( pos + 1 )) ), ((int) (( length - pos )) ));
					global::System.Array.Copy(((global::System.Array) (a1) ), ((int) (0) ), ((global::System.Array) (a1) ), ((int) (0) ), ((int) (pos) ));
				}
				
				a1[pos] = x;
				return a1;
			}
		}
		
		
		public static double[] insertFloat(double[] a, int length, int pos, double x) {
			unchecked {
				double[] a1 = a;
				int capacity = ( a1 as global::System.Array ).Length;
				if (( pos == length )) {
					if (( capacity == length )) {
						double[] newarr = new double[( (( length << 1 )) + 1 )];
						( a1 as global::System.Array ).CopyTo(((global::System.Array) (newarr) ), ((int) (0) ));
						a1 = newarr;
					}
					
				}
				else if (( pos == 0 )) {
					if (( capacity == length )) {
						double[] newarr1 = new double[( (( length << 1 )) + 1 )];
						global::System.Array.Copy(((global::System.Array) (a1) ), ((int) (0) ), ((global::System.Array) (newarr1) ), ((int) (1) ), ((int) (length) ));
						a1 = newarr1;
					}
					else {
						global::System.Array.Copy(((global::System.Array) (a1) ), ((int) (0) ), ((global::System.Array) (a1) ), ((int) (1) ), ((int) (length) ));
					}
					
				}
				else if (( capacity == length )) {
					double[] newarr2 = new double[( (( length << 1 )) + 1 )];
					global::System.Array.Copy(((global::System.Array) (a1) ), ((int) (0) ), ((global::System.Array) (newarr2) ), ((int) (0) ), ((int) (pos) ));
					global::System.Array.Copy(((global::System.Array) (a1) ), ((int) (pos) ), ((global::System.Array) (newarr2) ), ((int) (( pos + 1 )) ), ((int) (( length - pos )) ));
					a1 = newarr2;
				}
				else {
					global::System.Array.Copy(((global::System.Array) (a1) ), ((int) (pos) ), ((global::System.Array) (a1) ), ((int) (( pos + 1 )) ), ((int) (( length - pos )) ));
					global::System.Array.Copy(((global::System.Array) (a1) ), ((int) (0) ), ((global::System.Array) (a1) ), ((int) (0) ), ((int) (pos) ));
				}
				
				a1[pos] = x;
				return a1;
			}
		}
		
		
		public static object[] insertDynamic(object[] a, int length, int pos, object x) {
			unchecked {
				object[] a1 = a;
				int capacity = ( a1 as global::System.Array ).Length;
				if (( pos == length )) {
					if (( capacity == length )) {
						object[] newarr = new object[( (( length << 1 )) + 1 )];
						( a1 as global::System.Array ).CopyTo(((global::System.Array) (newarr) ), ((int) (0) ));
						a1 = newarr;
					}
					
				}
				else if (( pos == 0 )) {
					if (( capacity == length )) {
						object[] newarr1 = new object[( (( length << 1 )) + 1 )];
						global::System.Array.Copy(((global::System.Array) (a1) ), ((int) (0) ), ((global::System.Array) (newarr1) ), ((int) (1) ), ((int) (length) ));
						a1 = newarr1;
					}
					else {
						global::System.Array.Copy(((global::System.Array) (a1) ), ((int) (0) ), ((global::System.Array) (a1) ), ((int) (1) ), ((int) (length) ));
					}
					
				}
				else if (( capacity == length )) {
					object[] newarr2 = new object[( (( length << 1 )) + 1 )];
					global::System.Array.Copy(((global::System.Array) (a1) ), ((int) (0) ), ((global::System.Array) (newarr2) ), ((int) (0) ), ((int) (pos) ));
					global::System.Array.Copy(((global::System.Array) (a1) ), ((int) (pos) ), ((global::System.Array) (newarr2) ), ((int) (( pos + 1 )) ), ((int) (( length - pos )) ));
					a1 = newarr2;
				}
				else {
					global::System.Array.Copy(((global::System.Array) (a1) ), ((int) (pos) ), ((global::System.Array) (a1) ), ((int) (( pos + 1 )) ), ((int) (( length - pos )) ));
					global::System.Array.Copy(((global::System.Array) (a1) ), ((int) (0) ), ((global::System.Array) (a1) ), ((int) (0) ), ((int) (pos) ));
				}
				
				a1[pos] = ((object) (x) );
				return a1;
			}
		}
		
		
		public static string[] insertString(string[] a, int length, int pos, string x) {
			unchecked {
				string[] a1 = a;
				int capacity = ( a1 as global::System.Array ).Length;
				if (( pos == length )) {
					if (( capacity == length )) {
						string[] newarr = new string[( (( length << 1 )) + 1 )];
						( a1 as global::System.Array ).CopyTo(((global::System.Array) (newarr) ), ((int) (0) ));
						a1 = newarr;
					}
					
				}
				else if (( pos == 0 )) {
					if (( capacity == length )) {
						string[] newarr1 = new string[( (( length << 1 )) + 1 )];
						global::System.Array.Copy(((global::System.Array) (a1) ), ((int) (0) ), ((global::System.Array) (newarr1) ), ((int) (1) ), ((int) (length) ));
						a1 = newarr1;
					}
					else {
						global::System.Array.Copy(((global::System.Array) (a1) ), ((int) (0) ), ((global::System.Array) (a1) ), ((int) (1) ), ((int) (length) ));
					}
					
				}
				else if (( capacity == length )) {
					string[] newarr2 = new string[( (( length << 1 )) + 1 )];
					global::System.Array.Copy(((global::System.Array) (a1) ), ((int) (0) ), ((global::System.Array) (newarr2) ), ((int) (0) ), ((int) (pos) ));
					global::System.Array.Copy(((global::System.Array) (a1) ), ((int) (pos) ), ((global::System.Array) (newarr2) ), ((int) (( pos + 1 )) ), ((int) (( length - pos )) ));
					a1 = newarr2;
				}
				else {
					global::System.Array.Copy(((global::System.Array) (a1) ), ((int) (pos) ), ((global::System.Array) (a1) ), ((int) (( pos + 1 )) ), ((int) (( length - pos )) ));
					global::System.Array.Copy(((global::System.Array) (a1) ), ((int) (0) ), ((global::System.Array) (a1) ), ((int) (0) ), ((int) (pos) ));
				}
				
				a1[pos] = x;
				return a1;
			}
		}
		
		
		public static global::haxe.lang.FieldHashConflict getHashConflict(global::haxe.lang.FieldHashConflict head, int hash, string name) {
			while (( head != null )) {
				if (( ( head.hash == hash ) && ( head.name == name ) )) {
					return head;
				}
				
				head = head.next;
			}
			
			return null;
		}
		
		
		public static void setHashConflict(ref global::haxe.lang.FieldHashConflict head, int hash, string name, object @value) {
			global::haxe.lang.FieldHashConflict node = head;
			while (( node != null )) {
				if (( ( node.hash == hash ) && ( node.name == name ) )) {
					node.@value = @value;
					return;
				}
				
				node = ((global::haxe.lang.FieldHashConflict) (node.next) );
			}
			
			head = ((global::haxe.lang.FieldHashConflict) (new global::haxe.lang.FieldHashConflict(hash, name, @value, ((global::haxe.lang.FieldHashConflict) (head) ))) );
		}
		
		
		public static bool deleteHashConflict(ref global::haxe.lang.FieldHashConflict head, int hash, string name) {
			if (( head == null )) {
				return false;
			}
			
			if (( ( head.hash == hash ) && ( head.name == name ) )) {
				head = ((global::haxe.lang.FieldHashConflict) (head.next) );
				return true;
			}
			
			global::haxe.lang.FieldHashConflict prev = head;
			global::haxe.lang.FieldHashConflict node = head.next;
			while (( node != null )) {
				if (( ( node.hash == hash ) && ( node.name == name ) )) {
					prev.next = node.next;
					return true;
				}
				
				node = node.next;
			}
			
			return false;
		}
		
		
		public static void addHashConflictNames(global::haxe.lang.FieldHashConflict head, global::haxe.root.Array arr) {
			while (( head != null )) {
				arr.push(head.name);
				head = head.next;
			}
			
		}
		
		
	}
}


